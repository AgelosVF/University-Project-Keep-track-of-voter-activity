	
  O κώδικας μου έχει πολλά comments για το τι κάνουν και επιστρέφουν τα functions που ορίζω και τι κάνουν 
 εντολές που θεωρώ ότι χρειάζεται κάποια επεξήγηση. Κάθε function που χρησιμοποιεί η main (η οποία βρίσκεται
 στο αρχείο Scan_Menu) που δεν βρίσκεται στο αρχείο της, δηλώνεται στο αρχείο MVote.h και από πάνω του έχει
 ένα comment για το τη κάνει. Υπάρχουν συναρτήσεις στα αρχεία οι οποίες δεν βρίσκονται στο Mvote.h επειδή
 δεν χρειάζεται ή δεν θέλω να έχουν όλοι σε αυτές.

Main : Υλοποίηση στο αρχείο Scan_Menu.c 
	  Η main ξεκινάει και ελέγχει αν πήρε τα 4 arguments που χρειάζεται αν ναι τότε καλεί την συνάρτηση 
	init_table() για να φτιάξει το hashtable. H hash_table δημιουργεί ένα hashtable με 2 αρχικά buckets 
	που μπορούν να έχουν bucket_entries χωρίς να κάνουν overflow. Μετά ανοίγει το αρχείο filename και 
	μέσω fscanf() διαβάζει από αυτό, κάνει malloc voters και αποθηκεύει pointers σε αυτούς στο hashtable.
	Τέλος επιστρέφει έναν pointer στο hashtable.

	  Μετά η main ξεκινάει ένα while(1) που περιμένει να διαβάσει εντολές. Διαβάζει εντολές μέσω της 
	συνάρτησης read_text η οποία κάνει fgets και επιστρέφει το string μετά από όταν του αφαιρέσει τον
	\n χαρακτήρα. Αφού πάρει πίσω το string η main χρησιμοποιεί strtok_r() για να χωρίσει το πρώτο 
	token του string από την αρχή μέχρι το πρώτο κενό χαρακτήρα. Έτσι έχοντας το command απομονωμένο
	ξεκινάει ένα if-else if-... όπου μέσω strcmp() βρίσκει αν το command είναι κάποιο από αυτά που 
	ξέρει να εκτελεί.

	  Όταν βρει ποιο command είναι χρησιμοποιεί ξανά strtok_r() για να απομονώσει τα υπόλοιπα flags.
	Αν υπάρχει κάποιο λάθος στην εντολή ( λάθος flag ή διαφορετικός αριθμός από ότι θα έπρεπε ) κάνει
	printf ένα μήνυμα ότι προέκυψε λάθος και κάνει continue. Για να χειριστεί περιπτώσεις οπού αντί για
	κάποιον ακέραιο πήρε string της μορφής 12α23 ή 123α, σε εντολές όπως η "-m pin " καλεί τη συνάρτηση
	read_int() η οποία πρώτα ελέγχει αν το string έχει μόνο αριθμούς και μετά κάνει atoi() για να το 
	μετατρέψει σε int. Αν υπάρχει κάποιο λάθος επιστρέφει -1 αλλιώς τον αριθμό.
	
	  Έχω επίσης προσθέσει δυο περισσότερα commands από αυτά που ζητούσε η άσκηση Το man, που τυπώνει
	τα commands που υπάρχουν και τα flags που χρειάζονται, και το pt το οποίο τυπώνει το hashtable.

	  Νομίζω το μόνο άλλο if που χρειάζεται να περιγράψω είναι πάρω το command exit αφού όλα τα υπόλοιπα
	συμπεριφέρονται όπως περιέγραψα πιο πάνω και καλούν την αντίστοιχη συνάρτηση του hashtable ή του linked list.
	Το exit καλεί πρώτα την συνάρτηση για να κάνει free τo linked list ( αν υπάρχει ) και μετά το hashtable. H
	destroy του linked list κάνει free μονό τα nodes του και το array που έχει τους pointers του ενώ η destroy
	του hashtable κάνει free τις δομές του άλλα και τους voters που δείχνει. Έτσι όταν τερματίζει το πρόγραμμα
	έχει κάνει free τα πάντα και αποφεύγει να κάνει 2 φορές free τους voters. Επίσης η ll_destroy() και 
	hashtable_destroy() χρησιμοποιούν τη συνάρτηση μου my_free() ( βρίσκεται στο αρχείο my_free.c ) η οποία
	κάνει malloc_usable_size() και μετά free() και επιστρέφει το μέγεθος που της έδωσε η malloc_usable_size(). 
	Έτσι μπορούν να επιστρέψουν το πόσα bytes έγιναν free για να το τυπώσω με το exit. To μέγεθος που τυπώνω
	είναι μόνο τα bytes που έγιναν free στο τέλος ελευθερώνοντας τις δομές δεδομένων και τους voters οπότε
	διαφέρει από το μέγεθος που δίνει το valgrind που μετράει και τα free στο runtime ( όταν κάνω free
	κάποιον voter λόγο error ή realloc ( που μερικές φορές κάνει free) ).

Δομή HashTable: Υλοποίηση στο αρχείο HashTable.c

	  Το hashtable το έφτιαξα βασισμένος στην περιγραφή linear hashing που δόθηκε με την εκφώνηση της
	εργασίας. Μια αλλαγή που έκανα ήταν αντί να φτιάξω κάποιο struct bucket, το κάθε bucket μου
	είναι ένα linked list. Έτσι μπορώ να βάζω καινούργια objects στα bucket πιο γρήγορα, βάζοντας τα στην
	αρχή της λίστας ( O(1) ), και να χειρίζομαι το overflow και split των buckets πιο εύκολα. 
	  Το hashtable struct μου ορίζεται ως:  
		struct hash_table{
			unsigned int init_buckets; // ο αριθμός των αρχικών buckets όταν δημιουργώ το table
			unsigned int current_buckets;// ο αριθμός των buckets αυτή την στιγμή στο table
			int bucket_size; // ο αριθμός των objects που μπορεί να περιέχει ένα bucket χωρίς 
			//overflow
			unsigned int round; // το round/level hashing στο οποίο βρίσκεται
			int p;// ένας αριθμός που χρησιμοποιώ (αντί για pointer) για index του πιο θα είναι το 
			// bucket που θα γίνει split.
			int num_keys;// ο αριθμός των objects που περιέχει το hashtable μου.
			hash_object **bucket_list;// Ένα array pointers. Κάθε pointer θα δείχνει στο πρώτο
			//object του linked list που είναι το κάθε bucket.
			};

	 Τα hash_object που περιέχει το hashtable ορίζονται ως:
		typedef struct hash_object{
			int pin;
			voter *vtr;
			struct hash_object *next;
		}hash_object;

	   Για το split έχω ορίσει το λ=0.75 και ελέγχω αν το (num_keys)/( current_buckets * bucket_size) ξεπερνάει το
	λ. Αν ναι τότε κανω realloc για να μεγαλώσω το bucket_list κατά ένα και για κάθε object στο bucket που αντιστίχει
	στο index p καλώ τo hash_function για round+1 για να δω αν θα το βάλω στο καινούργιο bucket ή θα το αφίσω σε αυτό
	που ήταν.
	   Το hash_function που χρησιμοποίησα για να υπολογίζω σε ποιο bucket μπαίνει το κάθε object είναι το 
	(voter_pin) mod( (2^round) *( init_buckets) ). Όταν κάνω split, ή αναζητώ κάποιων voter σε bucket που
	έχει κάνει split σε αυτό το round και δεν τον βρήκα στο bucket που μου έδωσε το hash_function, χρησιμοποιώ
        το ( voter_pin )mod( 2^( round+1 )*( init_buckets ) ).
	
	Time complexity: -Search = O(1) το hashfunction υπολογίζει το bucket που βρίσκεται και κάνω search μόνο
				  μέσα στα στοιχειά του. Στην χείριστη περίπτωση O(n) αν όλα τα στοιχεία είναι
				  σε ένα bucket (ή δυο που ήταν ένα και έκανε split) και είναι το τελευταία της
				  λίστας.
			 -Split = O(n) που n είναι τα στοιχειά του bucket κάνω split αφού ελέγχω όλα τα στοιχειά
			 	 του bucket.
			 -Ιnsert = O(1) αντίστοιχα με το search το hashfunction μου δίνει την λίστα στην οποία θα
				  αποθηκεύσω το στοιχειό και το βάζω στην αρχή της. Επειδή όμως δεν θέλω να έχω
				  duplicates η insert κάνει search πρώτα για να δει αν υπάρχει ήδη μέσα το στοιχείο 
				  άρα υπάρχει περίπτωση να πάρει 0(n). Επίσης αν μετά την insert χρειαστεί να κάνω
				  split ένα bucket με n στοιχεία θα χρειαστεί να περιμένει 0(n) πριν τερματίσει.
	  
	
	
Δομή LinkedList: Υλοποίηση στο αρχείο LinkedList.c
	  Για να αποθηκεύσω τους voters που έχουν ψηφήσει έφτιαξα ένα double linked list όπου κάθε node έχει: τον
	ταχυδρομικό κώδικα που αντιστοιχεί, τον αριθμό αυτών που έχουν ψηφίσει με αυτό τον τ.κ. και έναν πινάκα
	με pointers στους αντίστοιχους voters, έναν pointer στο επόμενο node και άλλον ένα  pointer στο επόμενο
	node. Τα node ορίζονται ως:
		struct list_node{
			int tk;
			int people;
			voter **voter_list;
			struct list_node *next_n;
			struct list_node *prev_n;
			

		};

	  Επέλεξα να φτιάξω double linked list γιατί σκόπευα να έχω τα nodes ταξινομημένα προς τους voters έτσι
	ώστε όταν καλώ την ll_print_tk_num_voters(list_node *node) για να τυπώσω τους τ.κ. και το πόσοι voters
	έχουν ψηφίσει να μην χρειάζεται να τους ταξινομήσω. Άλλα είχα ένα bug όταν έκανα swap τα nodes και αποφάσισα
	να αφήσω τα nodes στην σειρά που τα δημιουργώ. Αντί για αυτό η ll_print_tk_num_voters() φτιάχνει δυναμικά
	ένα 2d array που αποθηκεύει τα τ.κ. και voters του κάθε node πηγαίνοντας από το head στο end του list και 
	κάθε φορά που βάζει ένα row στον πινάκα το κάνει swap με το προηγούμενο μέχρι το προηγούμενο να έχει 
	περισσότερους voters από αυτό.

	  Επειδή στη main έχω πρόσβαση μόνο στον πρώτο κόμβο της λίστας τα read και search έχουν complexity O(n).
	Ενώ το να κάνω print τον αριθμό αυτών που έχουν ψηφίσει σε κάθε τ.κ. ταξινομημένους σε φθίνουσα σειρά
	έχει σε χείριστη περίπτωση 0(n^2) όπου n είναι τα nodes της λίστας δηλαδή το σύνολο των διαφορετικών
	τ.κ. στους οποίους έχουν ψηφίσει.
